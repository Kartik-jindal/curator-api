from typing import List, Optional

from sqlalchemy.orm import Session
from sqlalchemy import desc
from . import models, schemas, security

def get_user_by_email(db: Session, email:str):
    return db.query(models.User).filter(models.User.email == email).first()
    # This function queries the database for a user with a specific email.
    # db.query(models.User): Start a query on the 'users' table.
    # .filter(models.User.email == email): Add a WHERE clause to the query.
    # .first(): Execute the query and return only the first result found, or None if no user is found.

def create_user(db: Session, user: schemas.UserCreate):
    """
    Creates a new user in the database.
    1. Hashes the plain-text password.
    2. Creates a new SQLAlchemy User model instance.
    3. Adds it to the session, commits it to the DB, and refreshes the instance.
    """
    # Step 1: Hash the password from the incoming user data.
    hashed_password = security.get_password_hash(user.password)

    # Step 2: Create a SQLAlchemy User model instance from the data.
    # We DON'T store the plain 'user.password'. We store the 'hashed_password'.
    db_user = models.User(
        email=user.email, 
        full_name=user.full_name,
        hashed_password=hashed_password
    )

    # Step 3: Add the new user object to the database session.
    db.add(db_user)

    # Step 4: Commit the changes to the database. This is what actually saves it. 
    db.commit()

    # Step 5: Refresh the 'db_user' instance. This makes the database return
    # the new data that was created, like the auto-generated 'id' and 'created_at'.
    db.refresh(db_user)
    
    # Step 6: Return the new user instance.
    return db_user

def create_user_content(db: Session, content: schemas.ContentCreate, user_id: int) -> models.Content:
    """Creates a new content item in the DB associated with a user."""
    db_content = models.Content(**content.dict(), owner_id=user_id)
    db.add(db_content)
    db.commit()
    db.refresh(db_content)
    return db_content

def create_tag(db: Session, tag: schemas.TagCreate) -> models.Tag:
    """
    Creates and saves a new tag to the database.

    Args:
        db (Session): The SQLAlchemy database session dependency.
        tag (schemas.TagCreate): A Pydantic model containing the data for the new tag
                                (in this case, just the 'name').

    Returns:
        models.Tag: The new SQLAlchemy Tag object that has been saved to the database,
                    including its database-generated ID.
    """
    # Create an instance of our SQLAlchemy `Tag` model.
    # We get the 'name' from the Pydantic `tag` object.
    db_tag = models.Tag(name=tag.name)
    
    # Add the new model instance to the session (staging area).
    db.add(db_tag)
    
    # Commit the session to write the new tag to the database.
    db.commit()
    
    # Refresh the `db_tag` instance to get the values generated by the database,
    # like the new 'id'.
    db.refresh(db_tag)
    
    # Return the complete, saved Tag object.
    return db_tag

def add_tag_to_content(db: Session, content: models.Content, tag: models.Tag) -> models.Content:
    """
    Associates a tag with a piece of content in the database.

    This function appends a Tag object to the `tags` relationship list
    of a Content object. SQLAlchemy's ORM handles the logic of creating
    the new record in the `content_tags_association` table.

    Args:
        db (Session): The SQLAlchemy database session dependency.
        content (models.Content): The SQLAlchemy Content object to which the tag will be added.
        tag (models.Tag): The SQLAlchemy Tag object to add.

    Returns:
        models.Content: The updated Content object with the new tag associated.
    """
    # Check if the tag is not already associated with the content
    if tag not in content.tags:
        # The magic of SQLAlchemy's relationship() feature.
        # Simply appending the `tag` object to the `content.tags` list
        # stages the creation of a new row in the association table.
        content.tags.append(tag)
        
        # We need to commit the session to save this new association.
        db.commit()
        db.refresh(content)
        
    # Return the content object, which now reflects the new association.
    return content

def get_content(db: Session, skip: int = 0, limit: int = 100) -> List[models.Content]:
    """Returns a list of all content items, with pagination."""
    return db.query(models.Content).offset(skip).limit(limit).all()

def get_user_feed(db: Session, user: models.User, skip: int = 0, limit: int = 100) -> List[models.Content]:
    """
    Constructs a personalized feed for a user based on the tags they follow.

    The query performs the following steps:
    1. Identifies all tags the user follows.
    2. Joins the Content and Tag tables via the content_tags_association table.
    3. Filters the content to include only items tagged with one of the user's followed tags.
    4. Removes duplicate content items.
    5. Orders the final list by the content's creation date (newest first).
    6. Applies pagination (skip/limit).

    Args:
        db (Session): The SQLAlchemy database session.
        user (models.User): The authenticated user for whom to generate the feed.
        skip (int): The number of items to skip for pagination.
        limit (int): The maximum number of items to return.

    Returns:
        List[models.Content]: A list of Content objects for the user's feed.
    """
    # 1. Get the IDs of the tags the user follows.
    followed_tag_ids = [tag.id for tag in user.followed_tags]

    # If the user follows no tags, their feed is empty.
    if not followed_tag_ids:
        return []

    # 2. Construct the complex query.
    feed_query = (
        db.query(models.Content)
        # Join Content with its tags relationship.
        .join(models.Content.tags)
        # Filter to get content where the tag's ID is in our list of followed tags.
        .filter(models.Tag.id.in_(followed_tag_ids))
        # Ensure we don't get duplicate content items.
        .distinct()
        # Order the results so the newest content is first.
        .order_by(desc(models.Content.created_at))
        # Apply pagination.
        .offset(skip)
        .limit(limit)
    )
    
    # 3. Execute the query and return the results.
    return feed_query.all()

def get_content_by_id(db: Session, content_id: int) -> Optional[models.Content]:
    """Returns a single content item by its ID, or None if not found."""
    return db.query(models.Content).filter(models.Content.id == content_id).first()

def update_content(
    db: Session, 
    content: models.Content, 
    content_update: schemas.ContentCreate
) -> models.Content:
    """
    Updates an existing content item in the database.

    Args:
        db (Session): The SQLAlchemy database session.
        content (models.Content): The existing SQLAlchemy Content object to be updated.
        content_update (schemas.ContentCreate): A Pydantic model with the new data for the content.

    Returns:
        models.Content: The updated SQLAlchemy Content object.
    """
    # Get the Pydantic model as a dictionary
    update_data = content_update.dict(exclude_unset=True)
    
    # Iterate over the key-value pairs in the update data
    for key, value in update_data.items():
        # Use setattr to dynamically set the attribute on the SQLAlchemy model
        setattr(content, key, value)
        
    # The `content` object is now "dirty" in the session.
    # We commit the session to write the changes to the database.
    db.commit()
    # Refresh the instance to get the final state from the database.
    db.refresh(content)
    
    return content

def get_tag_by_id(db: Session, tag_id: int) -> Optional[models.Tag]:
    """Retrieves a single tag from the database by its primary key ID."""
    return db.query(models.Tag).filter(models.Tag.id == tag_id).first()

def delete_content_by_id(db: Session, content_id: int) -> Optional[models.Content]:
    """Deletes a content item from the DB by its ID."""
    db_content = db.query(models.Content).filter(models.Content.id == content_id).first()
    if db_content:
        db.delete(db_content)
        db.commit()
    return db_content

def follow_tag(db: Session, user: models.User, tag: models.Tag) -> models.User:
    """
    Creates an association for a user to follow a tag.

    Appends the Tag object to the User's `followed_tags` relationship list.
    SQLAlchemy's ORM handles creating the record in the `user_followed_tags_association` table.

    Args:
        db (Session): The SQLAlchemy database session.
        user (models.User): The User object who is following the tag.
        tag (models.Tag): The Tag object being followed.

    Returns:
        models.User: The updated User object, now reflecting the new followed tag.
    """
    # Check if the user is not already following the tag to prevent duplicates.
    if tag not in user.followed_tags:
        # Append the tag object to the user's relationship list.
        # This stages the creation of a new row in the association table.
        user.followed_tags.append(tag)
        
        db.commit()
        db.refresh(user)
        
    return user

def unfollow_tag(db: Session, user: models.User, tag: models.Tag) -> models.User:
    """
    Deletes the association for a user following a tag.

    Removes the Tag object from the User's `followed_tags` relationship list.
    SQLAlchemy's ORM handles deleting the corresponding record in the
    `user_followed_tags_association` table.

    Args:
        db (Session): The SQLAlchemy database session.
        user (models.User): The User object who is unfollowing.
        tag (models.Tag): The Tag object being unfollowed.

    Returns:
        models.User: The updated User object, with the tag association removed.
    """
    # Check if the user is currently following the tag before trying to remove it.
    if tag in user.followed_tags:
        # The inverse of append() is remove().
        # This stages the deletion of the row in the association table.
        user.followed_tags.remove(tag)
        
        db.commit()
        db.refresh(user)
        
    return user

def get_tag_by_name(db: Session, name: str) -> Optional[models.Tag]:
    """
    Retrieves a single tag from the database by its unique name.

    Args:
        db (Session): The SQLAlchemy database session dependency.
        name (str): The name of the tag to retrieve. The search is case-sensitive.

    Returns:
        Optional[models.Tag]: The SQLAlchemy Tag object if a tag with the
                              exact name is found, otherwise returns None.
    """
    # Start a query on the Tag model (the 'tags' table).
    # Apply a filter to find a row where the 'name' column matches the provided name.
    # .first() executes the query and returns the first result or None.
    return db.query(models.Tag).filter(models.Tag.name == name).first()


def get_user_by_id(db: Session, user_id: int) -> Optional[models.User]:
    """
    Retrieves a single user from the database by their primary key ID.
    """
    return db.query(models.User).filter(models.User.id == user_id).first()
