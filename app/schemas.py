# app/schemas.py

# --- IMPORTS ---
# We import BaseModel from Pydantic, which gives our schema classes data validation powers.
from pydantic import BaseModel
# We import standard Python typing tools to make our schemas clearer and more robust.
from typing import List, Optional
# We import datetime to correctly type-hint date and time fields.
from datetime import datetime


# --- BASE SCHEMAS ---
# These "Base" schemas contain fields that are common to other schemas.
# This helps us avoid repeating code (DRY principle).

class TagBase(BaseModel):
    # 'name' is a required string field. Pydantic will enforce this.
    name: str

class ContentBase(BaseModel):
    # 'title' and 'url' are required string fields.
    title: str
    url: str
    # 'description' is an optional string. If not provided, it defaults to None.
    description: Optional[str] = None


# --- "CREATE" SCHEMAS ---
# These schemas define the exact shape of the data we expect in an API request body
# when a user wants to CREATE a new item. Think of them as "input forms".

class TagCreate(TagBase):
    # This class inherits all fields from TagBase ('name').
    # We use 'pass' because no additional fields are needed to create a tag.
    pass

class ContentCreate(ContentBase):
    # This inherits all fields from ContentBase ('title', 'url', 'description').
    # We use 'pass' as no extra fields are needed for initial content creation.
    pass

class UserCreate(BaseModel):
    # This schema is used for creating a new user (registration).
    # 'email' is a required string. Pydantic will also do basic email format validation.
    email: str
    # 'password' is a required string. We expect the plain-text password here.
    password: str
    # 'full_name' is an optional string for the user's name.
    full_name: Optional[str] = None


# --- "READ" SCHEMAS ---
# These schemas define the exact shape of the data we will send back in an API response.
# They often include fields generated by the database (like 'id' and 'created_at')
# and can hide sensitive information (like passwords).

class Tag(TagBase):
    # This is the "read" model for a Tag. It inherits 'name' from TagBase.
    # We add the 'id' field, which is an integer generated by the database.
    id: int

    # This nested 'Config' class provides configuration to Pydantic.
    class Config:
        # 'orm_mode = True' tells Pydantic to read the data from a SQLAlchemy object
        # (an ORM model) instead of just a dictionary. It's the bridge between
        # our database models and our API schemas.
        orm_mode = True

class Content(ContentBase):
    # The "read" model for Content. Inherits 'title', 'url', 'description'.
    # We add fields that exist in the database but are not part of creation.
    id: int
    owner_id: int
    created_at: datetime
    # This line is powerful. It tells Pydantic that the 'tags' attribute
    # should be a list, where each item in the list is a 'Tag' schema object.
    # Pydantic will handle the nested conversion automatically.
    tags: List[Tag] = []

    class Config:
        # Enable ORM mode to read from the Content SQLAlchemy model.
        orm_mode = True

class User(BaseModel):
    # The "read" model for a User. Notice it does NOT include the password.
    # This is a critical security measure.
    id: int
    email: str
    created_at: datetime
    # We tell Pydantic that a user response can include a list of their 'content'
    # and the 'tags' they follow, and Pydantic will use the corresponding schemas.
    content: List[Content] = []
    followed_tags: List[Tag] = []

    class Config:
        # Enable ORM mode to read from the User SQLAlchemy model.
        orm_mode = True

        
class Token(BaseModel):
    """
    Pydantic model for the authentication token response.
    This defines the shape of the JSON object returned upon successful login.
    """
    # The JWT access token itself.
    access_token: str
    
    # The type of the token, typically "bearer".
    token_type: str


class TokenData(BaseModel):
    """
    Pydantic model for the data encoded within the JWT.
    This is used when decoding a token to validate its contents.
    """
    # The 'subject' of the token, which we use to store the user's email.
    # It can be a string or None if the token is invalid or doesn't have a subject.
    email: str | None = None